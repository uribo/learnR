```{r knitsetup, echo=FALSE, results='hide', warning=FALSE, message=FALSE, cache=FALSE}
opts_knit$set(base.dir='./', fig.path='', out.format='md')
opts_chunk$set(prompt=TRUE, comment='', results='markup')
# See yihui.name/knitr/options for more Knitr options.
##### Put other setup R code here

```

# Data frame

A data frame is a table with a number of rows and columns. It looks like a matrix but its columns are not necessarily the same type. This is consistent with most data tables: a row, or data record is described by multiple columns of different types.

The following table is an example that can be fully characterized by a data frame.

| Name     | Gender | Age | Major            |
|----------|--------|-----|------------------|
| Ken      | Male   | 24  | Finance          |
| Ashley   | Female | 25  | Statistics       |
| Jennifer | Female | 23  | Computer Science |

## Creating data frame

To create such a data frame, we can call `data.frame` function and supply the data in each column.

```{r}
persons <- data.frame(Name=c("Ken","Ashley","Jennifer"),
  Gender=c("Male","Female","Female"),
  Age=c(24,25,23),
  Major=c("Finance","Statistics","Computer Science"))
persons
```

Note that creating a data frame is exactly the same with creating a list. It is because in essence a data frame *is* a list in which each member represents a column and has the same number of elements.

Other than creating a data frame from raw data, we can also create it from a list by calling either `data.frame` directly or `as.data.frame`.

```{r}
l1 <- list(x=c(1,2,3),y=c("a","b","c"))
data.frame(l1)
as.data.frame(l1)
```

We can also create a data frame from a matrix with the same method.

```{r}
m1 <- matrix(c(1,2,3,4,5,6,7,8,9),nrow=3,byrow=FALSE)
data.frame(m1)
as.data.frame(m1)
```

Note that the conversion also automatically assign column names to the new data frame. In fact, as you may verify, if the matrix already has column names or row names, they will be preserved in the conversion.

## Naming rows and columns

Since a data frame is a list but also looks like a matrix, the way we access these two types of objects both apply to data frame.

```{r}
df1 <- data.frame(id=1:5,x=c(0,2,1,-1,-3),y=c(0.5,0.2,0.1,0.5,0.9))
df1
```

We can rename the columns and rows just like how we do so with a matrix.

```{r}
colnames(df1) <- c("id","level","score")
rownames(df1) <- letters[1:5]
df1
```

## Subsetting data frame

Since data frame is a matrix-like list of columns, we can use both set of notations to access the elements and subsets in a data frame.

### Subsetting as a list

If we would like to regard a data frame as a list of columns, we can use list notations to extract value or perform subsetting.

For example, we can use the dollar-sign to extract the value of one column by name, or use double square brackets to do so by index.

```{r}
df1$id
df1[[1]]
```

List subsetting perfectly applies to a data frame and also yields new data frame. The single square brackets allows us to use an integer vector to extract columns by index, a character vector to extract columns by name, or a logical vector to extract columns by `TRUE` and `FALSE` selection.

```{r}
df1[1]
df1[1:2]
df1["level"]
df1[c("id","score")]
df1[c(TRUE,FALSE,TRUE)]
```

### Subsetting as a matrix

However, the list notation does not support row access. In contrast, the matrix notation provides more flexibility. If we view a data frame as a matrix, the two-dimensional accessor enables us to easily access an entry of a subset, which supports both column selection and row selection.

In other words, we can use `[row,column]` notation to subset a data frame by specifying the row selector and column selector, which can be integer vectors, character vectors, and/or logical vectors.

For example, we can specify the column selector:

```{r}
df1[,"level"]
df1[,c("id","level")]
df1[,1:2]
```

or the row selector:

```{r}
df1[1:4,]
df1[c("c","e"),]
```

or both selectors at the same time:

```{r}
df1[,"id"]
df1[1:4,"id"]
df1[1:3,c("id","score")]
```

Note that the matrix notation automatically simplifies the output. That is, if only one column is selected, the result won't be a data frame but the value of that column. To keep the result always being a data frame even if it only has a single column, we can use both notations together.

```{r}
df1[1:4,]["id"]
```

Here the first group of brackets subsets the data frame as a matrix with the first four rows and all columns selected. The second group of brackes subsets the resulted data frame as a list with only `id` column selected, which results in a data frame.

### Data filtering

The following code filters the rows of `df1` by a criterion that `score >= 0.5` and selects `id` and `level` columns:

```{r}
df1$score >= 0.5
df1[df1$score>=0.5,c("id","level")]
```

The following code filters the rows of `df1` by a criterion that the row name must be among a, d, or e, and selects the `id` and `score` columns.

```{r}
rownames(df1) %in% c("a","d","e")
df1[rownames(df1) %in% c("a","d","e"),c("id","score")]
```

Both examples above basically uses matrix notation to select rows by logical vector and select columns by character vector.

## Setting values

Setting the values or a subset of a data frame is almost the same as how we do so with either a list or a matrix.

### Setting values as a list

We can assign new values to a list member using `$` and `<-` together.

```{r}
df1$score <- c(0.6,0.3,0.2,0.4,0.8)
df1
```

Alternatively, single square brackets work too, but it also allows multiple changes in one expression in contrast with double square brackets.

```{r}
df1["score"] <- c(0.8,0.5,0.2,0.4,0.8)
df1
df1[["score"]] <- c(0.4,0.5,0.2,0.8,0.4)
df1
df1[c("level","score")] <- list(level=c(1,2,1,0,0),score=c(0.1,0.2,0.3,0.4,0.5))
df1
```

### Setting values as a matrix

Using list notations to set values of a data frame has the same problem with subsetting. We can only access the columns. If we need to set values with more flexibility, we can use matrix notations.

```{r}
df1[1:3,"level"] <- c(-1,0,1)
df1
df1[1:2,c("level","score")] <- list(level=c(0,0),score=c(0.9,1.0))
df1
```

## Factor

One thing to notice is that the default behavior of a data frame tries to use memory more efficiently. Sometimes this behavior might lead to unexpected problems silently.

For example, when we create a data frame by supplying a character vector as a column, it  will by default convert the character vector to a **factor** that only stores the same value once so that repetitions will not cost much memory.

We can verify this by calling `str` on data frame `persons` we created in the beginning.

```{r}
str(persons)
```

As we can clearly find out that `Name`, `Gender`, and `Major` are not character vectors but factor object. It is reasonable that `Gender` is represented by a factor because it may only be either `Female` or `Male` so that using two integers to represent these two values is more efficient than using character vector to store all the values regardless of the repetition.

However, it may induce problems for other columns not limited to take several possible values. For example, if we want to set a `Name` in `persons`,

```{r}
persons[1,"Name"] <- "John"
persons
```

a warning message appears. It happens because in the initial `Name` dictionary, there is no word called John, therefore we cannot set the name of the first person to be such "non-existing" value. The same thing happens when we set any `Gender` to be `Unknown`. The reason is the exactly the same: when the column is initially created from a character vector while we define a data frame, the column will by default be a factor whose value must be taken from the dictionary created from the unique values in that character vector.

This behavior is sometimes very annoying and does not really help much, especially when memory is cheap today. The simplist way to avoid this behavior is to set `stringsAsFactors = FALSE` when we create a data frame.

```{r}
persons <- data.frame(Name=c("Ken","Ashley","Jennifer"),
  Gender=factor(c("Male","Female","Female")),
  Age=c(24,25,23),
  Major=c("Finance","Statistics","Computer Science"),
  stringsAsFactors=FALSE)
str(persons)
```

If we really want factor object to play its role, we can explicitly call `factor` function at specific columns.

## Useful functions for data frame

There are many useful functions for data frame. Here we only introduce the a few most commonly used ones.

### Summarizing a data frame

`summary` function works with a data frame by generating a table that shows the summary statistics of each column.

```{r}
summary(persons)
```

For a factor (`Gender`) the summary counts the number of rows taking each value, or level. For a numeric vector, the summary shows the important quantiles of the numbers. For other types of columns, it shows the length, class, and mode of them.

### Binding data frames

cbind
rbind

## Load from/Write to a file

### Loading data frame from a file

read.table
read.csv

### Saving data frame to a file

write.table
write.csv
